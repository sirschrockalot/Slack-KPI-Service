name: Deploy to GKS (with Approval)

on:
  push:
    branches: [main]
    paths:
      - '**.js'
      - '**.json'
      - 'Dockerfile'
      - '.github/workflows/deploy-to-gks-with-approval.yml'
  pull_request:
    branches: [main]
    paths:
      - '**.js'
      - '**.json'
      - 'Dockerfile'
      - '.github/workflows/deploy-to-gks-with-approval.yml'
  workflow_dispatch: # Allow manual triggering

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  CLUSTER_NAME: ${{ secrets.GKS_CLUSTER_NAME }}
  CLUSTER_REGION: ${{ secrets.GKS_CLUSTER_REGION }}
  IMAGE_NAME: aircall-slack-service

jobs:
  # Job 1: Build and prepare for deployment
  build:
    name: Build and Prepare
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.build.outputs.image-tag }}
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      
    - name: Authenticate to Google Cloud
      id: auth
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
        
    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
      with:
        project_id: ${{ env.PROJECT_ID }}
        
    - name: Configure Docker for GCR
      run: gcloud auth configure-docker
      
    - name: Build and Push Docker Image
      id: build
      run: |
        # Build the image with commit SHA and latest tags
        docker build -t gcr.io/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}:${{ github.sha }} .
        docker build -t gcr.io/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}:latest .
        
        # Push images
        docker push gcr.io/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        docker push gcr.io/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}:latest
        
        # Set output for next job
        echo "image-tag=${{ github.sha }}" >> $GITHUB_OUTPUT
        
    - name: Create Deployment Summary
      run: |
        echo "## ðŸš€ Deployment Ready for Approval" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Image Built:** gcr.io/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}:${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "**Author:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Changes to be deployed:" >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY
        git log --oneline -10 >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY

  # Job 2: Manual approval step
  approve:
    name: Manual Approval
    runs-on: ubuntu-latest
    needs: build
    environment: production
    
    steps:
    - name: Wait for Approval
      run: |
        echo "âœ… Manual approval received!"
        echo "Proceeding with deployment to GKS cluster..."
        
    - name: Deployment Summary
      run: |
        echo "## âœ… Approved for Deployment" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Approved by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
        echo "**Approved at:** $(date)" >> $GITHUB_STEP_SUMMARY
        echo "**Image:** gcr.io/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }}" >> $GITHUB_STEP_SUMMARY

  # Job 3: Deploy to GKS (only after approval)
  deploy:
    name: Deploy to GKS
    runs-on: ubuntu-latest
    needs: [build, approve]
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      
    - name: Authenticate to Google Cloud
      id: auth
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
        
    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
      with:
        project_id: ${{ env.PROJECT_ID }}
        
    - name: Get GKS Credentials
      run: |
        gcloud container clusters get-credentials ${{ env.CLUSTER_NAME }} \
          --region ${{ env.CLUSTER_REGION }} \
          --project ${{ env.PROJECT_ID }}
          
    - name: Create Kubernetes Manifests
      run: |
        # Create namespace
        cat <<EOF | kubectl apply -f -
        apiVersion: v1
        kind: Namespace
        metadata:
          name: aircall-slack
          labels:
            name: aircall-slack
        EOF
        
        # Create deployment
        cat <<EOF | kubectl apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: aircall-slack-service
          namespace: aircall-slack
          labels:
            app: aircall-slack-service
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: aircall-slack-service
          template:
            metadata:
              labels:
                app: aircall-slack-service
            spec:
              containers:
              - name: aircall-slack-service
                image: gcr.io/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }}
                ports:
                - containerPort: 3000
                  name: http
                env:
                - name: PORT
                  value: "3000"
                - name: NODE_ENV
                  value: "production"
                resources:
                  requests:
                    memory: "128Mi"
                    cpu: "100m"
                  limits:
                    memory: "256Mi"
                    cpu: "200m"
                livenessProbe:
                  httpGet:
                    path: /health
                    port: 3000
                  initialDelaySeconds: 30
                  periodSeconds: 10
                  timeoutSeconds: 5
                  failureThreshold: 3
                readinessProbe:
                  httpGet:
                    path: /health
                    port: 3000
                  initialDelaySeconds: 5
                  periodSeconds: 5
                  timeoutSeconds: 3
                  failureThreshold: 3
        EOF
        
        # Create service
        cat <<EOF | kubectl apply -f -
        apiVersion: v1
        kind: Service
        metadata:
          name: aircall-slack-service
          namespace: aircall-slack
          labels:
            app: aircall-slack-service
        spec:
          type: ClusterIP
          ports:
          - port: 80
            targetPort: 3000
            protocol: TCP
            name: http
          selector:
            app: aircall-slack-service
        EOF
        
        # Create load balancer service
        cat <<EOF | kubectl apply -f -
        apiVersion: v1
        kind: Service
        metadata:
          name: aircall-slack-loadbalancer
          namespace: aircall-slack
          annotations:
            cloud.google.com/load-balancer-type: "External"
        spec:
          type: LoadBalancer
          ports:
          - port: 80
            targetPort: 3000
            protocol: TCP
            name: http
          selector:
            app: aircall-slack-service
        EOF
        
    - name: Wait for Deployment
      run: |
        kubectl rollout status deployment/aircall-slack-service -n aircall-slack --timeout=300s
        
    - name: Get Service URL
      id: deploy
      run: |
        # Wait a bit for the load balancer to be ready
        sleep 30
        
        # Get the load balancer IP
        LB_IP=$(kubectl get service aircall-slack-loadbalancer -n aircall-slack -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
        
        if [ -n "$LB_IP" ]; then
          echo "url=http://$LB_IP" >> $GITHUB_OUTPUT
          echo "Service URL: http://$LB_IP"
        else
          echo "url=http://pending" >> $GITHUB_OUTPUT
          echo "Load balancer IP not yet available"
        fi
        
    - name: Verify Deployment
      run: |
        echo "=== Deployment Status ==="
        kubectl get pods -n aircall-slack
        
        echo ""
        echo "=== Service Status ==="
        kubectl get services -n aircall-slack
        
        echo ""
        echo "=== Load Balancer IP ==="
        kubectl get service aircall-slack-loadbalancer -n aircall-slack -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || echo "Load balancer IP not yet available"
        
    - name: Health Check
      run: |
        # Wait a bit for the service to be ready
        sleep 30
        
        # Get the load balancer IP
        LB_IP=$(kubectl get service aircall-slack-loadbalancer -n aircall-slack -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
        
        if [ -n "$LB_IP" ]; then
          echo "Testing health endpoint at http://$LB_IP/health"
          curl -f http://$LB_IP/health || echo "Health check failed"
        else
          echo "Load balancer IP not available yet"
        fi
        
    - name: Deployment Complete
      run: |
        echo "## ðŸŽ‰ Deployment Complete!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Status:** âœ… Successfully deployed to GKS" >> $GITHUB_STEP_SUMMARY
        echo "**Image:** gcr.io/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }}" >> $GITHUB_STEP_SUMMARY
        echo "**Service URL:** ${{ steps.deploy.outputs.url }}" >> $GITHUB_STEP_SUMMARY
        echo "**Deployed at:** $(date)" >> $GITHUB_STEP_SUMMARY 