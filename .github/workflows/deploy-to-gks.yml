name: Deploy to GKS

on:
  push:
    branches: [main]
    paths:
      - '**.js'
      - '**.json'
      - 'Dockerfile'
      - '.github/workflows/deploy-to-gks.yml'
  pull_request:
    branches: [main]
    paths:
      - '**.js'
      - '**.json'
      - 'Dockerfile'
      - '.github/workflows/deploy-to-gks.yml'
  workflow_dispatch: # Allow manual triggering

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  CLUSTER_NAME: ${{ secrets.GKS_CLUSTER_NAME }}
  CLUSTER_REGION: ${{ secrets.GKS_CLUSTER_REGION }}
  IMAGE_NAME: aircall-slack-service

jobs:
  deploy:
    name: Deploy to GKS
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      
    - name: Authenticate to Google Cloud
      id: auth
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
        
    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
      with:
        project_id: ${{ env.PROJECT_ID }}
        
    - name: Configure Docker for GCR
      run: gcloud auth configure-docker
      
    - name: Get GKS Credentials
      run: |
        gcloud container clusters get-credentials ${{ env.CLUSTER_NAME }} \
          --region ${{ env.CLUSTER_REGION }} \
          --project ${{ env.PROJECT_ID }}
          
    - name: Build and Push Docker Image
      run: |
        # Build the image with commit SHA and latest tags
        docker build -t gcr.io/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}:${{ github.sha }} .
        docker build -t gcr.io/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}:latest .
        
        # Push images
        docker push gcr.io/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        docker push gcr.io/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}:latest
        
    - name: Create Kubernetes Manifests
      run: |
        # Create namespace
        cat <<EOF | kubectl apply -f -
        apiVersion: v1
        kind: Namespace
        metadata:
          name: aircall-slack
          labels:
            name: aircall-slack
        EOF
        
        # Create deployment
        cat <<EOF | kubectl apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: aircall-slack-service
          namespace: aircall-slack
          labels:
            app: aircall-slack-service
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: aircall-slack-service
          template:
            metadata:
              labels:
                app: aircall-slack-service
            spec:
              containers:
              - name: aircall-slack-service
                image: gcr.io/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
                ports:
                - containerPort: 3000
                  name: http
                env:
                - name: PORT
                  value: "3000"
                - name: NODE_ENV
                  value: "production"
                resources:
                  requests:
                    memory: "128Mi"
                    cpu: "100m"
                  limits:
                    memory: "256Mi"
                    cpu: "200m"
                livenessProbe:
                  httpGet:
                    path: /health
                    port: 3000
                  initialDelaySeconds: 30
                  periodSeconds: 10
                  timeoutSeconds: 5
                  failureThreshold: 3
                readinessProbe:
                  httpGet:
                    path: /health
                    port: 3000
                  initialDelaySeconds: 5
                  periodSeconds: 5
                  timeoutSeconds: 3
                  failureThreshold: 3
        EOF
        
        # Create service
        cat <<EOF | kubectl apply -f -
        apiVersion: v1
        kind: Service
        metadata:
          name: aircall-slack-service
          namespace: aircall-slack
          labels:
            app: aircall-slack-service
        spec:
          type: ClusterIP
          ports:
          - port: 80
            targetPort: 3000
            protocol: TCP
            name: http
          selector:
            app: aircall-slack-service
        EOF
        
        # Create load balancer service
        cat <<EOF | kubectl apply -f -
        apiVersion: v1
        kind: Service
        metadata:
          name: aircall-slack-loadbalancer
          namespace: aircall-slack
          annotations:
            cloud.google.com/load-balancer-type: "External"
        spec:
          type: LoadBalancer
          ports:
          - port: 80
            targetPort: 3000
            protocol: TCP
            name: http
          selector:
            app: aircall-slack-service
        EOF
        
    - name: Wait for Deployment
      run: |
        kubectl rollout status deployment/aircall-slack-service -n aircall-slack --timeout=300s
        
    - name: Verify Deployment
      run: |
        echo "=== Deployment Status ==="
        kubectl get pods -n aircall-slack
        
        echo ""
        echo "=== Service Status ==="
        kubectl get services -n aircall-slack
        
        echo ""
        echo "=== Load Balancer IP ==="
        kubectl get service aircall-slack-loadbalancer -n aircall-slack -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || echo "Load balancer IP not yet available"
        
    - name: Health Check
      run: |
        # Wait a bit for the service to be ready
        sleep 30
        
        # Get the load balancer IP
        LB_IP=$(kubectl get service aircall-slack-loadbalancer -n aircall-slack -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
        
        if [ -n "$LB_IP" ]; then
          echo "Testing health endpoint at http://$LB_IP/health"
          curl -f http://$LB_IP/health || echo "Health check failed"
        else
          echo "Load balancer IP not available yet"
        fi 