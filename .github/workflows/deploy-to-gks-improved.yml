name: Deploy to GKS (Improved)

on:
  push:
    branches: [main]
    paths:
      - '**.js'
      - '**.json'
      - 'Dockerfile'
      - 'k8s/**'
      - '.github/workflows/deploy-to-gks-improved.yml'
  pull_request:
    branches: [main]
    paths:
      - '**.js'
      - '**.json'
      - 'Dockerfile'
      - 'k8s/**'
      - '.github/workflows/deploy-to-gks-improved.yml'
  workflow_dispatch: # Allow manual triggering

# Required permissions for Workload Identity
permissions:
  id-token: write   # This is required for requesting the JWT
  contents: read    # This is required for actions/checkout

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  CLUSTER_NAME: ${{ secrets.GKS_CLUSTER_NAME }}
  CLUSTER_REGION: ${{ secrets.GKS_CLUSTER_REGION }}
  IMAGE_NAME: aircall-slack-service
  NAMESPACE: aircall-slack
  REGISTRY: us-central1-docker.pkg.dev
  REPOSITORY: docker-repo
  WORKLOAD_IDENTITY_PROVIDER: ${{ secrets.WORKLOAD_IDENTITY_PROVIDER }}
  GCP_SERVICE_ACCOUNT: ${{ secrets.GCP_SERVICE_ACCOUNT }}

jobs:
  # Job 1: Build and prepare for deployment
  build:
    name: Build and Prepare
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.build.outputs.image-tag }}
      image-digest: ${{ steps.build.outputs.image-digest }}
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      
    - name: Debug Secrets
      run: |
        echo "Checking if secrets are available..."
        echo "PROJECT_ID: ${{ env.PROJECT_ID }}"
        echo "CLUSTER_NAME: ${{ env.CLUSTER_NAME }}"
        echo "CLUSTER_REGION: ${{ env.CLUSTER_REGION }}"
        echo "WORKLOAD_IDENTITY_PROVIDER: ${{ env.WORKLOAD_IDENTITY_PROVIDER }}"
        echo "GCP_SERVICE_ACCOUNT: ${{ env.GCP_SERVICE_ACCOUNT }}"
        
        if [ -z "${{ env.WORKLOAD_IDENTITY_PROVIDER }}" ]; then
          echo "❌ WORKLOAD_IDENTITY_PROVIDER is empty!"
          exit 1
        fi
        
        if [ -z "${{ env.GCP_SERVICE_ACCOUNT }}" ]; then
          echo "❌ GCP_SERVICE_ACCOUNT is empty!"
          exit 1
        fi
        
        echo "✅ All required secrets are present"
      
    - name: Authenticate to Google Cloud
      id: auth
      uses: google-github-actions/auth@v2
      with:
        workload_identity_provider: ${{ env.WORKLOAD_IDENTITY_PROVIDER }}
        service_account: ${{ env.GCP_SERVICE_ACCOUNT }}
        
    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
      with:
        project_id: ${{ env.PROJECT_ID }}
        
    - name: Configure Docker for Artifact Registry
      run: gcloud auth configure-docker ${{ env.REGISTRY }}
      
    - name: Build and Push Docker Image
      id: build
      run: |
        # Build the image with commit SHA and latest tags
        docker build --platform linux/amd64 -t ${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} .
        docker build --platform linux/amd64 -t ${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}:latest .
        
        # Push images
        docker push ${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        docker push ${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}:latest
        
        # Get image digest for verification
        DIGEST=$(docker images --digests --format "table {{.Repository}}:{{.Tag}}\t{{.Digest}}" | grep "${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}" | awk '{print $2}')
        
        # Set outputs for next job
        echo "image-tag=${{ github.sha }}" >> $GITHUB_OUTPUT
        echo "image-digest=$DIGEST" >> $GITHUB_OUTPUT
        
    - name: Create Deployment Summary
      run: |
        echo "## 🚀 Deployment Ready for Approval" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Image Built:** ${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "**Image Digest:** ${{ steps.build.outputs.image-digest }}" >> $GITHUB_STEP_SUMMARY
        echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "**Author:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Changes to be deployed:" >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY
        git log --oneline -10 >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY

  # Job 2: Manual approval step
  approve:
    name: Manual Approval
    runs-on: ubuntu-latest
    needs: build
    environment: production
    
    steps:
    - name: Wait for Approval
      run: |
        echo "✅ Manual approval received!"
        echo "Proceeding with deployment to GKS cluster..."
        
    - name: Deployment Summary
      run: |
        echo "## ✅ Approved for Deployment" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Approved by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
        echo "**Approved at:** $(date)" >> $GITHUB_STEP_SUMMARY
        echo "**Image:** ${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }}" >> $GITHUB_STEP_SUMMARY

  # Job 3: Deploy to GKS (only after approval)
  deploy:
    name: Deploy to GKS
    runs-on: ubuntu-latest
    needs: [build, approve]
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      
    - name: Debug Secrets for Deploy
      run: |
        echo "Checking secrets for deployment job..."
        echo "PROJECT_ID: ${{ env.PROJECT_ID }}"
        echo "CLUSTER_NAME: ${{ env.CLUSTER_NAME }}"
        echo "CLUSTER_REGION: ${{ env.CLUSTER_REGION }}"
        echo "WORKLOAD_IDENTITY_PROVIDER: ${{ env.WORKLOAD_IDENTITY_PROVIDER }}"
        echo "GCP_SERVICE_ACCOUNT: ${{ env.GCP_SERVICE_ACCOUNT }}"
        
        if [ -z "${{ env.WORKLOAD_IDENTITY_PROVIDER }}" ]; then
          echo "❌ WORKLOAD_IDENTITY_PROVIDER is empty in deploy job!"
          exit 1
        fi
        
        if [ -z "${{ env.GCP_SERVICE_ACCOUNT }}" ]; then
          echo "❌ GCP_SERVICE_ACCOUNT is empty in deploy job!"
          exit 1
        fi
        
        echo "✅ All required secrets are present for deployment"
      
    - name: Authenticate to Google Cloud
      id: auth
      uses: google-github-actions/auth@v2
      with:
        workload_identity_provider: ${{ env.WORKLOAD_IDENTITY_PROVIDER }}
        service_account: ${{ env.GCP_SERVICE_ACCOUNT }}
        
    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
      with:
        project_id: ${{ env.PROJECT_ID }}
        
    - name: Get GKS Credentials
      run: |
        gcloud container clusters get-credentials ${{ env.CLUSTER_NAME }} \
          --region ${{ env.CLUSTER_REGION }} \
          --project ${{ env.PROJECT_ID }}
          
    - name: Update Image in Manifests
      run: |
        # Update the image tag in deployment.yaml
        sed -i "s|IMAGE_PLACEHOLDER|${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }}|g" k8s/deployment.yaml
        
        # Verify the change
        echo "Updated deployment.yaml with image: ${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }}"
        
    - name: Create Secrets (if not exists)
      run: |
        # Check if secrets exist
        if ! kubectl get secret aircall-slack-secrets -n ${{ env.NAMESPACE }} >/dev/null 2>&1; then
          echo "⚠️  Warning: aircall-slack-secrets not found. Please create it manually:"
          echo "   kubectl apply -f k8s/secrets.yaml"
          echo "   (Make sure to update the secrets.yaml with your actual values first)"
        else
          echo "✅ Secrets already exist"
        fi
        
    - name: Deploy to Kubernetes
      run: |
        echo "🚀 Deploying to GKS cluster..."
        
        # Apply manifests in order
        kubectl apply -f k8s/namespace.yaml
        kubectl apply -f k8s/configmap.yaml
        kubectl apply -f k8s/deployment.yaml
        kubectl apply -f k8s/service.yaml
        kubectl apply -f k8s/hpa.yaml
        
        # Optional: Apply ingress if you have a domain
        # kubectl apply -f k8s/ingress.yaml
        
        echo "✅ All manifests applied successfully"
        
    - name: Wait for Deployment
      run: |
        echo "⏳ Waiting for deployment to complete..."
        kubectl rollout status deployment/aircall-slack-service -n ${{ env.NAMESPACE }} --timeout=300s
        
        if [ $? -eq 0 ]; then
          echo "✅ Deployment completed successfully"
        else
          echo "❌ Deployment failed or timed out"
          exit 1
        fi
        
    - name: Verify Deployment
      run: |
        echo "🔍 Verifying deployment..."
        
        # Check pods
        echo "=== Pod Status ==="
        kubectl get pods -n ${{ env.NAMESPACE }} -l app=aircall-slack-service
        
        # Check services
        echo ""
        echo "=== Service Status ==="
        kubectl get services -n ${{ env.NAMESPACE }}
        
        # Check HPA
        echo ""
        echo "=== HPA Status ==="
        kubectl get hpa -n ${{ env.NAMESPACE }}
        
    - name: Get Service URL
      id: deploy
      run: |
        # Wait for load balancer to be ready
        echo "⏳ Waiting for load balancer to be ready..."
        sleep 30
        
        # Get the load balancer IP
        LB_IP=$(kubectl get service aircall-slack-loadbalancer -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
        
        if [ -n "$LB_IP" ]; then
          echo "url=http://$LB_IP" >> $GITHUB_OUTPUT
          echo "🌐 Service URL: http://$LB_IP"
        else
          echo "url=http://pending" >> $GITHUB_OUTPUT
          echo "⏳ Load balancer IP not yet available"
        fi
        
    - name: Health Check
      run: |
        echo "🏥 Performing health check..."
        
        # Wait a bit more for the service to be ready
        sleep 30
        
        # Get the load balancer IP
        LB_IP=$(kubectl get service aircall-slack-loadbalancer -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
        
        if [ -n "$LB_IP" ]; then
          echo "🔍 Testing health endpoint at http://$LB_IP/health"
          
          # Try health check multiple times
          for i in {1..5}; do
            if curl -f -s http://$LB_IP/health > /dev/null; then
              echo "✅ Health check passed on attempt $i"
              break
            else
              echo "⏳ Health check failed on attempt $i, retrying..."
              sleep 10
            fi
            
            if [ $i -eq 5 ]; then
              echo "❌ Health check failed after 5 attempts"
              exit 1
            fi
          done
        else
          echo "⚠️  Load balancer IP not available yet"
        fi
        
    - name: Deployment Complete
      run: |
        echo "## 🎉 Deployment Complete!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Status:** ✅ Successfully deployed to GKS" >> $GITHUB_STEP_SUMMARY
        echo "**Image:** ${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }}" >> $GITHUB_STEP_SUMMARY
        echo "**Image Digest:** ${{ needs.build.outputs.image-digest }}" >> $GITHUB_STEP_SUMMARY
        echo "**Service URL:** ${{ steps.deploy.outputs.url }}" >> $GITHUB_STEP_SUMMARY
        echo "**Deployed at:** $(date)" >> $GITHUB_STEP_SUMMARY
        echo "**Namespace:** ${{ env.NAMESPACE }}" >> $GITHUB_STEP_SUMMARY
        echo "**Cluster:** ${{ env.CLUSTER_NAME }}" >> $GITHUB_STEP_SUMMARY
